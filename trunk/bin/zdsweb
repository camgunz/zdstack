#!/usr/bin/env python

import os
import cgi
import sys
import getopt
import signal
import socket
import urllib
import logging
import tempfile
import urlparse

from BaseHTTPServer import HTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler

from pyfileutils import write_file

from ZDStack import set_configfile, load_configparser, get_configparser, \
                    get_server_proxy

###
# Change this to the full path of the alternate configuration file you wish
# to use.  For example:
#
#   CGI_CONFIGFILE = '/home/zdstack/.supersecretzdstackrc'
#
###

CGI_CONFIGFILE = None

###
# That's it, don't change anything else!
###

def __print_usage(msg=None):
    if msg:
        print >> sys.stderr, "\nError: %s" % (msg)
    print >> sys.stderr, """
zdsweb

zdsweb can be used 2 different ways:

  It can be used as a standalone webserver.  As a daemon, it needs some values
    set.  This can be done here on the command-line, or in the ZDStack
    configuration file (in the DEFAULT section).  The method for employing
    either method follows:

      - address:     -a [ address ]     | 'zdsweb_hostname = <address>'
      - port:        -p [ port ]        | 'zdsweb_port = <port>'
      - log folder:  -l [ log_folder ]  | 'zdsweb_log_folder = <folderpath>'
      - PID file:    -i [ pid_file ]    | 'zdsweb_pidfile = <filepath>'
      - config file: -c [ config_file ] | n/a

  If options are defined in the ZDStack configuration file, they can be over-
    ridden here on the command-line (command-line options take precedence).
    Log folder defaults to the system's temporary folder, and PID file defaults
    to 'zdsweb.pid' in the system's temporary folder.

  It can also be used as a CGI script.  To use a custom configuration file,
    you must specify its location within this file itself.  To do so, edit this
    file and change the following line in this file as instructed (instructions
    are in the file):

      CGI_CONFIGFILE = None

zdsweb determines whether or not its being run as a CGI script by checking for
the 'GATEWAY_INTERFACE' environment variable.  This is set automatically by
webservers, so this will only cause problems if you also have this variable
defined in your environment.
    
"""
    sys.exit(-1)

try:
    __opts, __args = getopt.gnu_getopt(sys.argv[1:], 'c:a:p:l:i:', [])
except getopt.GetoptError, ge:
    __print_usage(ge)
__opts = dict(__opts)
if CGI_CONFIGFILE:
    set_configfile(CGI_CONFIGFILE)
elif '-c' in __opts:
    set_configfile(__opts['-c'])
load_configparser()

CP = get_configparser()
RCP = get_configparser(raw=True)

###
# Dumbness follows
###

__x = [('-a', 'zdsweb_hostname', 'localhost'),
       ('-p', 'zdsweb_port', 80),
       ('-l', 'zdsweb_logfolder', tempfile.gettempdir()),
       ('-i', 'zdsweb_pidfile', os.path.join(tempfile.gettempdir(),
                                             'ZDSWeb.pid'))]

def __get_vals(index):
    x = __x[index]
    return __opts.get(x[0], CP.defaults().get(x[1], x[2]))

ADDRESS = __get_vals(0)
PORT = int(__get_vals(1))
LOG_FOLDER = __get_vals(2)
PID_FILE = __get_vals(3)

###
# End dumbness
###

ZDS_HOSTNAME = CP.get('DEFAULT', 'zdstack_rpc_hostname')
SCRIPT_NAME = os.environ.get('SCRIPT_NAME', '/')

def __fork():
    if hasattr(os, 'devnull'):
        devnull = os.devnull
    else:
        devnull = '/dev/null'
    stdin = stdout = stderr = devnull
    if os.fork():
        os._exit(0)
    os.chdir('/')
    os.umask(0)
    os.setsid()
    if os.fork():
        os._exit(0)
    sys.stdout.flush()
    sys.stderr.flush()
    # si = open(stdin, 'r')
    # so = open(logfile, 'a+')
    # se = open(logfile, 'a+', 0)
    # os.dup2(si.fileno(), sys.stdin.fileno())
    # os.dup2(so.fileno(), sys.stdout.fileno())
    # os.dup2(se.fileno(), sys.stderr.fileno())

def _parse_list( x):
    return [y.strip() for y in x.split(',')]

def _items_to_section(self, name, items):
    """Converts a list of items into a ConfigParser section.

    name:  a string representing the name of the section to
           generate.
    items: a list of option, value pairs (strings).

    """
    return '[%s]\n' % (name) + '\n'.join(["%s: %s" % x for x in items])

class ZDSInterface:

    proxy = get_server_proxy()

    def _get_zserv_info(self, zserv_name):
        return self.proxy.get_zserv_info(zserv_name)

    def _get_all_zserv_info(self):
        return self.proxy.get_all_zserv_info()

    def _get_zserv_dict(self, zserv_info):
        # zserv_info['name'] = zserv_info['name
        zserv_info['hostname'] = CP.get(zserv_name, 'hostname')
        max_players = CP.getint(zserv_name, 'max_players') or 16
        zserv_info['max_players'] = CP.getint(zserv_name, 'max_players')
        zserv_info['mode'] = CP.get(zserv_name, 'mode')
        optional_wads = _parse_list(CP.get(zserv_name, 'optional_wads'))
        wads = list()
        for wad in _parse_list(CP.get(zserv_name, 'wads')):
            if wad in optional_wads:
                wads.append(wad.join(['[', ']']))
            else:
                wads.append(wad)
        zserv_info['wads'] = ', '.join(wads)
        zserv_info['port'] = CP.getint(zserv_name, 'port')
        return zserv_info

    def _get_all_zserv_dicts(self):
        return [self._get_zserv_dict(x) for x in self._get_all_zserv_info()]

    def start_zserv(self, zserv_name):
        return self.proxy.start_zserv(zserv_name)

    def stop_zserv(self, zserv_name):
        return self.proxy.stop_zserv(zserv_name)

    def restart_zserv(self, zserv_name):
        return self.proxy.restart_zserv(zserv_name)

    def start_all_zservs(self):
        return self.proxy.start_all_zservs()

    def stop_all_zservs(self):
        return self.proxy.stop_all_zservs()

    def restart_all_zservs(self):
        return self.proxy.restart_all_zservs()

    def get_zserv_names(self):
        return CP.sections()

    def get_zserv(self, zserv_name):
        zserv_info = self._get_zserv_info(zserv_name)
        return self._get_zserv_dict(zserv_info)

    def get_all_zservs(self):
        all_zserv_info = self._get_all_zserv_info(zserv_name)
        return [self.get_zserv(x) for x in self.get_zserv_names()]

    def get_running_zservs(self):
        return [x for x in self.get_all_zservs() if x['is_running']]

    def get_stopped_zservs(self):
        return [x for x in self.get_all_zservs() if not x['is_running']]

    def get_zserv_config(self, zserv_name):
        return _items_to_section(zserv_name, RCP.items(zserv_name))

    def set_zserv_config(self, zserv_name):
        return self.proxy.set_zserv_config(zserv_name)

IFACE = ZDSInterface()

HEAD_TEMPLATE = """\
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>ZDStack Web Interface</title>
    <style type="text/css">
        body {
            font-family: sans-serif;
            color: white;
            background-color: black;
            font-size: .75em;
        }
        a { color: white; }
        a:visited { color: white; }
        a img { border: 0; }
        .centered { text-align: center; }
        .left { text-align: left; }
        .right { text-align: right; }
        .indented { margin-left: 1em; }
        .black { color: black; }
        .white { color: white; }
        .bold { font-weight: bold; }
        ul.unstyled { list-style-type: none; }
        .nolinebreak { white-space: nowrap; }
        thead { margin-top:1em; }
        tbody { margin-bottom: 1em; }
        tbody tr.odd { background-color: #151515; }
        table {
            border-spacing: .25em 0em;
            border-collapse: collapse;
            width: auto;
        }
        td,th {
            padding-left: .5em;
            padding-right: .5em;
            padding-bottom: .25em;
        }
        th { white-space: nowrap; }
        table#servers { border-spacing: 1em 0em; }
        td.serveroption {
            font-weight: bold;
            white-space: nowrap;
            /* text-align: right; */
        }
        div#line {
            border: 1px solid white;
            margin-bottom: 1em;
        }
        div#content {
            margin-right: auto;
            margin-left: auto;
            padding: 11px;
            background-color: black;
            /* background-color: #292915; */
            /*
            min-height: 544px;
            width: 1020px;
            padding: .75em;
            background: transparent fixed no-repeat top center;
            opacity: 0.9;
            filter:alpha(opacity=90);
            -moz-opacity:0.9;
            */
        }
    </style>
</head>"""

###
# content
###
BODY_TEMPLATE = """\
<body>
    <div id="content">
        <h1 class="right">ZDStack Web Interface</h1>
        <div id="line"></div>
        %(content)s
    </div>
</body>
</html>"""

###
# content, errors
###
ERROR_TEMPLATE = """\
<body>
    <div id="content">
        <h1 class="right">ZDStack Web Interface</h1>
        <div id="line"></div>
        <div id="error">%(errors)s</div>
        <div id="line"></div>
        %(content)s
    </div>
</body>
</html>"""

###
# servers
###
SERVERS_TEMPLATE = """\
        <table id="servers">
            <thead>
                <tr>
                    <th class="centered">Server Name</th>
                    <th class="centered">Players</th>
                    <th class="centered">Type</th>
                    <th class="centered">PWADs</th>
                    <th class="centered">Current Map</th>
                    <th class="centered">Port</th>
                    <th class="centered>Controls</th>
                </tr>
            </thead>
            <tbody>
            %(servers)s
            </tbody>
        </table>"""

###
# action, url_name, cap_action
###
CONTROL_TEMPLATE = """\
<a href=%s?action=%%(action)s&name=%%(url_name)s>%%(cap_action)s\
""" % (SCRIPT_NAME)

###
# name, players, max_players, mode, wads, map_name, map_number, port
###
SERVER_TEMPLATE = """\
                <tr>
                    <td class="nolinebreak">%%(name)s</td>
                    <td class="centered">%%(players)s / %%(max_players)s</td>
                    <td class="centered">%%(mode)s</td>
                    <td class=>%%(wads)s</td>
                    <td class="nolinebreak">%%(map_name)s :: MAP%%(map_number)s</td>
                    <td class="centered">%%(port)s :: <a href="zds://%s:%%(port)s">Join</a></td>
                    <td class="centered">
                        <form action="%s" method="POST"
                              enctype="application/x-www-form-urlencoded">
                        %%(controls)s
                        </form>
                    </td>
                </tr>""" % (ZDS_HOSTNAME, SCRIPT_NAME)

NO_SERVERS_TEMPLATE = "<div>No Servers Configured</div>"

def _add_control(controls, action, name):
    d = {'action': action, 'url_name': urllib.quote(name),
         'cap_action': action.capitalize()}
    controls.append(CONTROL_TEMPLATE % d)
    return controls

def _add_controls(self, zserv_dict):
    ###
    # get config
    # set config
    # start
    # stop
    # restart
    ###
    controls = list()
    _add_control(controls, 'get_config', zserv_dict['name'])
    _add_control(controls, 'set_config', zserv_dict['name'])
    if zserv_dict['is_running']:
        _add_control(controls, 'stop', zserv_dict['name'])
    else:
        _add_control(controls, 'start', zserv_dict['name'])
        _add_control(controls, 'restart', zserv_dict['name'])
    zserv_dict['controls'] = controls

class Page:

    ###
    # A couple things:
    #   - How do we handle errors?
    #   - Do we want an AJAX-style get_config thing?  I think... no?
    ###

    actions = {'start': IFACE.start_zserv,
               'stop': IFACE.stop_zserv,
               'restart': IFACE.restart_zserv,
               'start_all': IFACE.start_all_zservs,
               'stop_all': IFACE.stop_all_zservs,
               'restart_all': IFACE.restart_all_zservs,
               'get_config': IFACE.get_zserv_config,
               'set_config': IFACE.set_zserv_config}

    requires_name = ('start', 'stop', 'restart', 'get_config', 'set_config')

    def __init__(self, action=None, name=None):
        if not action:
            self._func = None
        elif action in requires_name:
            if not name:
                raise ValueError("Action %s requires a ZServ name" % (action))
            self._func = lambda: self.actions[action](name)
        else:
            if name:
                es = "Action %s does not act on a single ZServ"
                raise ValueError(es % (action))
            self._func = lambda: self.actions[action]()

    def render(self):
        errors = []
        all_zservs = []
        servers = []
        try:
            if self._func:
                self.func()
        except socket.error:
            template = ERROR_TEMPLATE
            d = {'content': '', 'errors': 'Could not connect to ZDStack'}
            return template % d
        except Exception, e:
            errors.append(str(e))
        try:
            all_zservs = IFACE.get_all_zservs()
        except socket.error:
            template = ERROR_TEMPLATE
            d = {'content': '', 'errors': 'Could not connect to ZDStack'}
            return template % d
        except Exception, e:
            errors.append(str(e))
        if all_zservs:
            for zserv_dict in all_zservs:
                servers.append(SERVER_TEMPLATE % _add_controls(zserv_dict))
            content = SERVERS_TEMPLATE % {'servers': '\n'.join(servers)}
        else:
            content = NO_SERVERS_TEMPLATE
        if errors:
            errors = ' | '.join(errors)
            template = ERROR_TEMPLATE
            d = {'content': content, 'errors': errors}
        else:
            errors = ''
            template = BODY_TEMPLATE
            d = {'content': content}
        return template % d

    def render_cgi(self):
        s = "Content-Type: text/html\r\nContent-Length: %d\r\n%s\r\n"
        page = self.render()
        return s % (len(page), page)

    def __call__(self):
        return self.render()

class ZDSHTTPRequestHandler(SimpleHTTPRequestHandler):

    def send_head(self, post=False):
        action = None
        name = None
        query = urlparse.urlparse(self.path).query
        if query:
            if not post:
                self.send_error(501, "Can only send query params when POSTing")
            query_dict = cgi.parse_qs(query)
            if 'action' in query_dict:
                if len(query_dict['action']) > 1:
                    es = "A maximum of 1 action per request is allowed"
                    self.send_error(400, es)
                action = query_dict['action'][0]
                if 'name' in query_dict:
                    if len(query_dict['name']) > 1:
                        es = "A maximum of 1 name per request is allowed"
                        self.send_error(400, es)
                    name = query_dict['name'][0]
            elif 'name' in query_dict:
                self.send_error(400, "Names require actions")
        try:
            output = Page(action=action, name=name).render()
        except Exception, e:
            self.send_error(500, str(e))
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.send_header('Content-Length', str(len(output)))
        # self.send_header("Last-Modified", self.date_time_string(fs.st_mtime))
        self.end_headers()
        return output

    def do_HEAD(self):
        self.send_head()

    def do_GET(self):
        output = self.send_head()
        self.wfile.write(output)

    def do_POST(self):
        output = self.send_head(post=True)
        self.wfile.write(output)

    def log_error(self, format, *args):
        logging.getLogger('zdsweb').error(format % args)

    def log_message(self, format, *args):
        logging.getLogger('zdsweb').info(format % args)

if 'GATEWAY_INTERFACE' in os.environ:
    ###
    # Only CGI should have GATEWAY_INTERFACE defined in their environment.
    ###
    action = None
    name = None
    query_dict = cgi.FieldStorage()
    if 'action' in query_dict:
        if len(query_dict['action']) > 1:
            es = "A maximum of 1 action per request is allowed"
            self.send_error(400, es)
        action = query_dict.get_first('action')
        if 'name' in query_dict:
            if len(query_dict['name']) > 1:
                es = "A maximum of 1 name per request is allowed"
                self.send_error(400, es)
            name = query_dict.get_first('name')
    elif 'name' in query_dict:
        self.send_error(400, "Names require actions")
    print Page(action=action, name=name).render_cgi()

else:
    if os.path.isfile(PID_FILE):
        print >> sys.stderr, "ZDSWeb is already running: %s\n" % (PID_FILE)
    __log_file = os.path.join(LOG_FOLDER, 'ZDSWeb.log')
    __log_format = '[%(asctime)s]%(message)s'
    __formatter = logging.Formatter(__log_format, '%Y-%m-%d %H:%M:%S')
    __handler = logging.handlers.TimedRotatingFileHandler(__log_file,
                                                          when='midnight',
                                                          backupCount=4)
    __handler.setFormatter(__formatter)
    logging.getLogger('zdsweb').addHandler(__handler)
    logging.getLogger('zdsweb').setLevel(logging.INFO)
    server_address = (ADDRESS, PORT)
    print "ZDSWeb starting up on %s:%s" % server_address
    __fork()
    write_file(str(os.getpid()), PID_FILE, overwrite=True)
    logging.info("ZDSWeb starting up on %s:%s" % server_address)
    HTTPServer(server_address, ZDSHTTPRequestHandler).serve_forever()

